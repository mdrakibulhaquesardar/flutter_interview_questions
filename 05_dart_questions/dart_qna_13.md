## প্রশ্ন ১১: Dart-এ `late` কীওয়ার্ডটি ব্যাখ্যা করুন। এটি কখন ব্যবহার করা উচিত?

**উত্তর:** Dart-এ `late` কীওয়ার্ডটি দুটি উদ্দেশ্যে ব্যবহার করা হয়:

১.  **Late Initialization:** এটি একটি নন-নাল্লাবেল ভেরিয়েবল ঘোষণা করতে ব্যবহার করা হয়, যার মান প্রাথমিকভাবে অ্যাসাইন করা হয় না, কিন্তু প্রথমবার অ্যাক্সেস করার সময় অ্যাসাইন করা হবে।

    
```
dart
    late String description;

    void main() {
      description = 'Experienced Dart programmer'; // Value is assigned later
      print(description); // Value is accessed and initialized
    }
    
```
যদি আপনি `late` ছাড়া নন-নাল্লাবেল ভেরিয়েবল ঘোষণা করেন এবং তাৎক্ষণিকভাবে ইনিশিয়েলাইজ না করেন, তাহলে কম্পাইল-টাইম ত্রুটি হবে।

২.  **Lazy Initialization (For top-level variables and static fields):** টপ-লেভেল ভেরিয়েবল বা স্ট্যাটিক ফিল্ডের ক্ষেত্রে, `late` ব্যবহার করলে তাদের মান প্রোগ্রাম চালু হওয়ার সাথে সাথে ইনিশিয়েলাইজ না হয়ে, প্রথমবার যখন তাদের অ্যাক্সেস করা হয় তখনই ইনিশিয়েলাইজ হয়। এটি রিসোর্স বাঁচানোর জন্য উপযোগী হতে পারে যদি সেই ভেরিয়েবল বা ফিল্ডগুলি সবসময় ব্যবহার না হয়।

    
```
dart
    late String apiKey = _fetchApiKey(); // _fetchApiKey() is called only when apiKey is used

    String _fetchApiKey() {
      print('Fetching API key...');
      return 'MY_SECRET_API_KEY';
    }

    void main() {
      print('App started');
      print(apiKey); // _fetchApiKey() is called here
    }
    
```
`late` ব্যবহার করা উচিত যখন:
* আপনি জানেন যে একটি নন-নাল্লাবেল ভেরিয়েবল ব্যবহার করার আগে অবশ্যই ইনিশিয়েলাইজ করা হবে, কিন্তু ঘোষণার সময় নয়।
* আপনি টপ-লেভেল ভেরিয়েবল বা স্ট্যাটিক ফিল্ডের জন্য লেজি ইনিশিয়ালাইজেশন চান।

সাবধানতা: `late` ভেরিয়েবল অ্যাক্সেস করার আগে যদি ইনিশিয়েলাইজ না করা হয়, তাহলে রানটাইম ত্রুটি (`LateInitializationError`) ঘটবে।

## প্রশ্ন ১২: Dart-এ এক্সটেনশন মেথড (Extension Methods) কী এবং কীভাবে ব্যবহার করবেন?

**উত্তর:** Dart এক্সটেনশন মেথড আপনাকে বিদ্যমান ক্লাসগুলিতে নতুন কার্যকারিতা যোগ করতে দেয়, সেই ক্লাসগুলির সোর্স কোড পরিবর্তন না করেই। এটি বিশেষ করে যখন আপনি থার্ড-পার্টি লাইব্রেরি থেকে ক্লাস ব্যবহার করছেন এবং সেগুলিতে অতিরিক্ত মেথড যোগ করতে চান তখন খুব উপযোগী।

এক্সটেনশন মেথড তৈরি করার জন্য `extension` কীওয়ার্ড ব্যবহার করা হয়:

```
dart
extension StringExtensions on String {
  String capitalize() {
    if (isEmpty) {
      return this;
    }
    return this[0].toUpperCase() + substring(1);
  }

  String reverse() {
    return split('').reversed.join('');
  }
}

void main() {
  String name = "flutter";
  print(name.capitalize()); // Output: Flutter
  print(name.reverse());   // Output: rettulf

  String emptyString = "";
  print(emptyString.capitalize()); // Output:
}
```
এখানে, আমরা `StringExtensions` নামের একটি এক্সটেনশন তৈরি করেছি যা `String` ক্লাসে কাজ করে। আমরা `capitalize()` এবং `reverse()` নামের দুটি নতুন মেথড যোগ করেছি। এখন `String` টাইপের যেকোনো অবজেক্ট এই নতুন মেথডগুলি ব্যবহার করতে পারবে।

এক্সটেনশন মেথডের সুবিধা:
*  বিদ্যমান ক্লাসে নতুন কার্যকারিতা যোগ করা সহজ।
*  কোড রিডেবিলিটি এবং মেইনটেইনেন্স উন্নত করে।
*  ইউটিলিটি ফাংশনগুলিকে আরও অবজেক্ট-ওরিয়েন্টেড উপায়ে লেখার সুযোগ দেয়।

## প্রশ্ন ১৩: Dart-এ মিক্সিন (Mixins) কী? ইন্টারফেস এবং অ্যাবস্ট্রাক্ট ক্লাসের সাথে এর পার্থক্য কী?

**উত্তর:** মিক্সিন হল কোড পুনরায় ব্যবহার করার একটি উপায়। Dart-এ, একটি মিক্সিন একটি ক্লাসকে অন্য ক্লাসের কার্যকারিতা (মেথড এবং ইনস্ট্যান্স ভেরিয়েবল) ব্যবহার করতে দেয়, যদিও সেই ক্লাসটি তার প্যারেন্ট ক্লাস না হয়। একটি মিক্সিন তৈরি করার জন্য `mixin` কীওয়ার্ড ব্যবহার করা হয়।

একটি ক্লাস এক বা একাধিক মিক্সিন ব্যবহার করতে পারে `with` কীওয়ার্ড ব্যবহার করে:
```
dart
mixin CanFly {
  void fly() {
    print('Flying!');
  }
}

mixin CanSwim {
  void swim() {
    print('Swimming!');
  }
}

class Duck with CanFly, CanSwim {
  void quack() {
    print('Quack!');
  }
}

void main() {
  var duck = Duck();
  duck.fly();
  duck.swim();
  duck.quack();
}
```
**পার্থক্য:**

*   **মিক্সিন:** কোড পুনরায় ব্যবহার করার একটি উপায়। এটি একাধিক ক্লাসের ইমপ্লিমেন্টেশন শেয়ার করতে ব্যবহার করা হয়। একটি মিক্সিন নিজস্ব কনস্ট্রাক্টর থাকতে পারে না। একটি মিক্সিন নিজে থেকে ইনস্ট্যানশিয়েট করা যায় না।
*   **ইন্টারফেস:** একটি কন্ট্রাক্ট বা চুক্তি যা একটি ক্লাসকে অবশ্যই ইমপ্লিমেন্ট করতে হবে। Dart-এ কোনো ডেডিকেটেড `interface` কীওয়ার্ড নেই; যেকোনো ক্লাস একটি ইন্টারফেস হিসেবে ব্যবহার করা যেতে পারে। ইন্টারফেস শুধুমাত্র মেথড স্বাক্ষর (signatures) ঘোষণা করে, ইমপ্লিমেন্টেশন নয়।
*   **অ্যাবস্ট্রাক্ট ক্লাস:** আংশিক ইমপ্লিমেন্টেশন সহ একটি ক্লাস। এতে অ্যাবস্ট্রাক্ট মেথড (ইমপ্লিমেন্টেশন ছাড়া মেথড) এবং কনক্রিট মেথড (ইমপ্লিমেন্টেশন সহ মেথড) থাকতে পারে। অ্যাবস্ট্রাক্ট ক্লাস সরাসরি ইনস্ট্যানশিয়েট করা যায় না। এটি ইনহেরিটেন্সের জন্য বেস ক্লাস হিসেবে ব্যবহৃত হয়।

সহজ ভাষায়, ইন্টারফেস বলে "কী করতে হবে", অ্যাবস্ট্রাক্ট ক্লাস বলে "কীভাবে কিছুটা করতে হবে এবং বাকিটা সাবক্লাসকে করতে হবে", এবং মিক্সিন বলে "কারো কার্যকারিতা ব্যবহার করো"।

## প্রশ্ন ১৪: Dart-এ ফ্যাক্টরি কনস্ট্রাক্টর (Factory Constructor) কী এবং এটি কখন ব্যবহার করা হয়?

**উত্তর:** ফ্যাক্টরি কনস্ট্রাক্টর হল একটি বিশেষ ধরনের কনস্ট্রাক্টর যা নতুন ইনস্ট্যান্স তৈরি করার পরিবর্তে বিদ্যমান ইনস্ট্যান্স ফেরত দিতে পারে বা সাবক্লাসের ইনস্ট্যান্স তৈরি করতে পারে। এটি `factory` কীওয়ার্ড দিয়ে ঘোষণা করা হয়।

ফ্যাক্টরি কনস্ট্রাক্টরের মূল বৈশিষ্ট্য হল এটি সবসময় একটি নতুন ইনস্ট্যান্স তৈরি করে না। এটি ক্যাশে থেকে বিদ্যমান ইনস্ট্যান্স ফেরত দিতে পারে বা লজিকের উপর ভিত্তি করে ভিন্ন ধরনের ইনস্ট্যান্স তৈরি করতে পারে।

এটি কখন ব্যবহার করা হয়:
*   যখন আপনি একটি সিঙ্গেলটন ক্লাস তৈরি করতে চান (ক্লাসের শুধুমাত্র একটি ইনস্ট্যান্স থাকবে)।
*   যখন আপনি ক্যাশে করা ইনস্ট্যান্স ফেরত দিতে চান।
*   যখন আপনি একটি কনস্ট্রাক্টরের মাধ্যমে ভিন্ন ধরনের অবজেক্ট তৈরি করতে চান (ফ্যাক্টরি প্যাটার্ন)।
*   যখন কনস্ট্রাক্টরের মধ্যে কিছু জটিল লজিক বা অ্যাসিঙ্ক্রোনাস অপারেশন প্রয়োজন হয় (যদিও অ্যাসিঙ্ক্রোনাস কনস্ট্রাক্টর সরাসরি সম্ভব নয়, ফ্যাক্টরি কনস্ট্রাক্টর একটি ফিউচার ফেরত দিতে পারে)।

উদাহরণ: সিঙ্গেলটন প্যাটার্ন ব্যবহার করে একটি ফ্যাক্টরি কনস্ট্রাক্টর:

```
dart
class Database {
  static final Database _instance = Database._internal();

  factory Database() {
    return _instance;
  }

  Database._internal(); // Private constructor

  void connect() {
    print('Database connected');
  }
}

void main() {
  var db1 = Database();
  var db2 = Database();

  print(identical(db1, db2)); // Output: true (Both refer to the same instance)
}
```
এই উদাহরণে, `factory Database()` কনস্ট্রাক্টরটি নতুন `Database` ইনস্ট্যান্স তৈরি করার পরিবর্তে সর্বদা প্রাইভেট `_instance` ভেরিয়েবলটি ফেরত দেয়, যা নিশ্চিত করে যে ক্লাসের কেবলমাত্র একটি ইনস্ট্যান্স বিদ্যমান।

## প্রশ্ন ১৫: Dart-এ ইটারেটর (Iterator) এবং ইটারেবল (Iterable) কী?

**উত্তর:**

*   **ইটারেবল (Iterable):** ইটারেবল হল এমন একটি কালেকশন যা ক্রমানুসারে অ্যাক্সেস করা যায়। এটি একটি সিকোয়েন্স বা সিরিজের প্রতিনিধিত্ব করে। List, Set, এবং Map (keys, values, entries) সবই ইটারেবলের উদাহরণ। একটি ইটারেবল আপনাকে এর উপাদানগুলিতে লুপ করতে দেয়। একটি ইটারেবল থেকে আপনি একটি ইটারেটর পেতে পারেন।
```
dart
    List<int> numbers = [1, 2, 3, 4, 5];
    // numbers is an Iterable
    for (int number in numbers) {
      print(number);
    }
    
```
*   **ইটারেটর (Iterator):** ইটারেটর হল একটি অবজেক্ট যা একটি ইটারেবলের উপাদানগুলির উপর দিয়ে লুপ করতে ব্যবহৃত হয়। এটি `moveNext()` মেথড ব্যবহার করে কালেকশনের পরবর্তী উপাদানে যায় এবং `current` প্রপার্টি ব্যবহার করে বর্তমান উপাদানের মান ফেরত দেয়।

    
```
dart
    List<int> numbers = [1, 2, 3, 4, 5];
    Iterator<int> iterator = numbers.iterator;

    while (iterator.moveNext()) {
      print(iterator.current);
    }
    
```
সহজ ভাষায়, ইটারেবল হল "জিনিসগুলির একটি সংগ্রহ যা পুনরাবৃত্তি করা যেতে পারে", এবং ইটারেটর হল "যে বস্তুটি আপনাকে সংগ্রহে থাকা জিনিসগুলির উপর দিয়ে একটি করে যেতে সাহায্য করে"।

## প্রশ্ন ১৬: Dart-এ জেনারেটর ফাংশন (Generator Functions) কী?

**উত্তর:** জেনারেটর ফাংশন হল বিশেষ ধরনের ফাংশন যা মানগুলির একটি সিকোয়েন্স অলসভাবে (lazily) তৈরি করে। অর্থাৎ, তারা যখন প্রয়োজন হয় তখনই মান তৈরি করে, আগে থেকে তৈরি করে মেমরিতে রাখে না। এটি বিশেষ করে বড় ডেটাসেট বা অসীম সিকোয়েন্স নিয়ে কাজ করার সময় খুব উপযোগী হতে পারে।

Dart-এ দুই ধরনের জেনারেটর ফাংশন আছে:

১.  **সিনক্রোনাস জেনারেটর:** এই ফাংশনগুলি ইটারেবল রিটার্ন করে এবং প্রতিটি মান তৈরি করার জন্য `yield` কীওয়ার্ড ব্যবহার করে।
```
dart
    Iterable<int> count(int max) sync* {
      for (int i = 1; i <= max; i++) {
        yield i; // Yields a value and pauses
      }
    }

    void main() {
      var numbers = count(5); // No values generated yet
      for (int number in numbers) {
        print(number); // Values are generated one by one as needed
      }
    }
    
```
২.  **অ্যাসিঙ্ক্রোনাস জেনারেটর:** এই ফাংশনগুলি স্ট্রীম রিটার্ন করে এবং প্রতিটি মান তৈরি করার জন্য `yield` কীওয়ার্ড ব্যবহার করে। এগুলো সাধারণত অ্যাসিঙ্ক্রোনাস অপারেশন থেকে ডেটা স্ট্রিম করার জন্য ব্যবহৃত হয়।
```
dart
    Stream<int> countAsync(int max) async* {
      for (int i = 1; i <= max; i++) {
        await Future.delayed(Duration(seconds: 1)); // Simulate async work
        yield i; // Yields a value and pauses
      }
    }

    void main() async {
      print('Starting async count...');
      await for (int number in countAsync(5)) { // Consumes the stream
        print(number);
      }
      print('Async count finished.');
    }
    
```
জেনারেটর ফাংশন মেমরি সাশ্রয় করে কারণ এটি ডেটার পুরো সিকোয়েন্সটিকে একবারে মেমরিতে লোড করে না।

## প্রশ্ন ১৭: Dart-এ টাইপ ডেফিনিশন (Type Definition) বা টাইপ এলিয়াস (Type Alias) কী?

**উত্তর:** টাইপ ডেফিনিশন বা টাইপ এলিয়াস আপনাকে বিদ্যমান টাইপের জন্য একটি নতুন নাম তৈরি করতে দেয়। এটি জটিল টাইপ স্বাক্ষরগুলিকে (যেমন ফাংশন টাইপ বা জেনেরিক টাইপ) সহজবোধ্য করার জন্য ব্যবহৃত হয়। এটি কোডের পঠনযোগ্যতা বাড়ায়।

Dart-এ `typedef` কীওয়ার্ড ব্যবহার করে টাইপ এলিয়াস তৈরি করা হয়:
```
dart
// Type alias for a function that takes two integers and returns an integer
typedef IntOperation = int Function(int a, int b);

int add(int x, int y) => x + y;
int subtract(int x, int y) => x - y;

void performOperation(int a, int b, IntOperation operation) {
  print(operation(a, b));
}

void main() {
  performOperation(10, 5, add);      // Output: 15
  performOperation(10, 5, subtract); // Output: 5
}
```
এখানে, `IntOperation` হল `int Function(int a, int b)` টাইপের জন্য একটি এলিয়াস। এটি ফাংশন প্যারামিটার বা রিটার্ন টাইপ ঘোষণা করার সময় কোডটিকে আরও পরিষ্কার করে তোলে।

আপনি জেনেরিক টাইপের জন্যও টাইপ এলিয়াস ব্যবহার করতে পারেন:
```
dart
typedef MapOfStrings = Map<String, String>;

MapOfStrings myMap = {'key1': 'value1', 'key2': 'value2'};
```
`typedef` কোডের জটিলতা কমিয়ে পঠনযোগ্যতা উন্নত করতে সাহায্য করে।

## প্রশ্ন ১৮: Dart-এ মেটাডেটা (Metadata) বা অ্যানোটেশন (Annotations) কী? উদাহরণ দিন।

**উত্তর:** Dart-এ মেটাডেটা হল কোডের সাথে যুক্ত অতিরিক্ত তথ্য যা কম্পাইল-টাইম বা রানটাইমে ব্যবহার করা যেতে পারে। এটি কোডের আচরণের উপর প্রভাব ফেলে না, তবে টুলস, লাইব্রেরি বা ফ্রেমওয়ার্ক দ্বারা ব্যবহার করা যেতে পারে। মেটাডেটা `@` প্রতীক দিয়ে শুরু হয়, এরপর মেটাডেটা অ্যানোটেশনের নাম থাকে।

সাধারণত ব্যবহৃত মেটাডেটা অ্যানোটেশনগুলি হলো:
*   `@required`: এই অ্যানোটেশনটি প্যারামিটার বা প্রপার্টি নির্দেশ করে যা অবশ্যই প্রদান করতে হবে। (যদিও Dart 2.12 এর পরে Null Safety আসায় এর ব্যবহার কমে গেছে, তবে কিছু ক্ষেত্রে এটি এখনও ব্যবহৃত হয়, বিশেষ করে লিগ্যাসি কোডে বা নির্দিষ্ট লাইব্রেরিতে।)
*   `@deprecated`: এই অ্যানোটেশনটি নির্দেশ করে যে একটি ক্লাস, মেথড, বা ভেরিয়েবল আর ব্যবহার করা উচিত নয় এবং ভবিষ্যতে সরিয়ে ফেলা হতে পারে। এটি ব্যবহার করলে IDE তে একটি ওয়ার্নিং দেখায়।
*   `@override`: এটি নির্দেশ করে যে একটি সাবক্লাস সুপারক্লাসের একটি মেথড ওভাররাইড করছে। এটি একটি ভাল অভ্যাস কারণ এটি কম্পাইল-টাইমে ভুল ধরতে সাহায্য করে।

উদাহরণ:

```
dart
class Animal {
  void makeSound() {
    print('Generic animal sound');
  }
}

class Dog extends Animal {
  @override // Indicates that makeSound is overriding the superclass method
  void makeSound() {
    print('Bark!');
  }

  @deprecated // This method should no longer be used
  void deprecatedMethod() {
    print('This method is deprecated.');
  }
}

void main() {
  var dog = Dog();
  dog.makeSound(); // Output: Bark!
  dog.deprecatedMethod(); // IDE will show a warning
}
```
আপনি নিজের কাস্টম মেটাডেটা অ্যানোটেশনও তৈরি করতে পারেন একটি কনস্ট্যান্ট কনস্ট্রাক্টর সহ ক্লাস তৈরি করে।

## প্রশ্ন ১৯: Dart-এ টপ-লেভেল কোড (Top-Level Code) কী?

**উত্তর:** Dart ফাইলে কোনো ক্লাস বা ফাংশনের বাইরে সরাসরি লেখা কোডকে টপ-লেভেল কোড বলা হয়। এর মধ্যে টপ-লেভেল ভেরিয়েবল, টপ-লেভেল ফাংশন এবং ক্লাস/মিক্সিন/এনাম/টাইপ ডেফিনিশন ঘোষণা অন্তর্ভুক্ত।

উদাহরণ:
```
dart
// Top-level variable
const String appName = 'My Flutter App';

// Top-level function
void printGreeting(String name) {
  print('Hello, $name!');
}

// Top-level class declaration
class MyClass {
  // ... class members
}

void main() {
  // This is inside a function, not top-level code
  print(appName);
  printGreeting('World');
}
```
`main()` ফাংশনটি একটি টপ-লেভেল ফাংশন, তবে `main()` ফাংশনের ভিতরে লেখা কোড টপ-লেভেল কোড নয়। টপ-লেভেল ভেরিয়েবলগুলি লেজি ইনিশিয়েলাইজড হয় যদি না তারা `final` বা `const` হয়। টপ-লেভেল ফাংশনগুলি যেকোনো জায়গা থেকে সরাসরি কল করা যেতে পারে।

## প্রশ্ন ২০: Dart-এ ডিফার্ড লোডিং (Deferred Loading) বা লেজি লোডিং (Lazy Loading) কী? এটি কীভাবে ইমপ্লিমেন্ট করবেন?

**উত্তর:** ডিফার্ড লোডিং বা লেজি লোডিং আপনাকে আপনার অ্যাপ্লিকেশনের কিছু লাইব্রেরি বা অংশ লোড করা বিলম্বিত করতে দেয় যতক্ষণ না সেগুলো আসলে প্রয়োজন হয়। এটি আপনার অ্যাপ্লিকেশনের প্রাথমিক লোডিং সময় কমাতে সাহায্য করতে পারে, বিশেষ করে যদি আপনার অ্যাপে কিছু অংশ থাকে যা সব ব্যবহারকারী দ্বারা ব্যবহৃত হয় না।

Dart-এ ডিফার্ড লোডিং ইমপ্লিমেন্ট করার জন্য `deferred as` কীওয়ার্ড ব্যবহার করা হয় যখন একটি লাইব্রেরি ইম্পোর্ট করা হয়, এবং তারপর লাইব্রেরি লোড করার জন্য `loadLibrary()` মেথড ব্যবহার করা হয়।

উদাহরণ:

ধরা যাক আপনার কাছে একটি লাইব্রেরি ফাইল আছে `my_library.dart` এর মধ্যে:
```
dart
// my_library.dart
void heavyComputation() {
  print('Performing heavy computation...');
  // ... some complex code
}
```
এবং আপনার প্রধান ফাইল `main.dart`:
```
dart
// main.dart
import 'my_library.dart' deferred as my_lib;

void main() {
  print('App started');

  // my_lib is not loaded yet

  // Load the library when needed
  loadAndRun();
}

Future<void> loadAndRun() async {
  print('Loading library...');
  await my_lib.loadLibrary(); // Load the deferred library
  print('Library loaded.');

  my_lib.heavyComputation(); // Now you can use the functions/classes from the library
}
```
এই উদাহরণে, `my_library.dart` ফাইলটি অ্যাপ চালু হওয়ার সাথে সাথে লোড হবে না। এটি শুধুমাত্র `loadAndRun()` ফাংশন কল করা হলে এবং `my_lib.loadLibrary()` মেথড সম্পন্ন হলে লোড হবে।

ডিফার্ড লোডিং ব্যবহারের সুবিধা:
*   অ্যাপের প্রাথমিক লোডিং সময় কমে আসে।
*   অ্যাপের আকার কমে আসে (যদি ডিফার্ড লাইব্রেরিগুলি খুব বড় হয়)।
*   বিশেষ করে ওয়েব অ্যাপ্লিকেশনের জন্য উপযোগী যেখানে ব্যান্ডউইথ একটি বিবেচ্য বিষয় হতে পারে।

সীমাবদ্ধতা:
*   ডিফার্ড লাইব্রেরিতে থাকা টপ-লেভেল ভেরিয়েবলগুলি অ্যাক্সেস করার জন্য লাইব্রেরি লোড হওয়ার জন্য অপেক্ষা করতে হবে।
*   ডিফার্ড লাইব্রেরির প্রকার (types) সরাসরি `main` ফাংশনের রিটার্ন টাইপে ব্যবহার করা উচিত নয় কারণ লোডিং সম্পূর্ণ না হওয়া পর্যন্ত টাইপ উপলব্ধ নাও হতে পারে।