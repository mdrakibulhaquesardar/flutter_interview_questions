## ডার্ট সাক্ষাৎকার প্রশ্ন ও উত্তর (০৯)

**প্রশ্ন ১:** ডার্টে মিক্সিন (Mixin) কী এবং কেন ব্যবহার করা হয়?

**উত্তর:** মিক্সিন হলো এক ধরনের ক্লাস যা অন্য ক্লাসে তার মেথড এবং প্রোপার্টি ব্যবহার করার অনুমতি দেয়, কিন্তু উত্তরাধিকারের মতো শ্রেণিবিন্যাস তৈরি করে না। এটি কোড পুনরায় ব্যবহার (code reuse) এবং একাধিক উত্তরাধিকারের (multiple inheritance) কিছু সীমাবদ্ধতা অতিক্রম করতে ব্যবহৃত হয়। একটি ক্লাসে মিক্সিন ব্যবহার করতে `with` কিওয়ার্ড ব্যবহার করা হয়।

**উদাহরণ:**

```
dart
mixin Logger {
  void log(String message) {
    print('[LOG] $message');
  }
}

class MyClass with Logger {
  void doSomething() {
    log('Doing something...');
  }
}
```
**প্রশ্ন ২:** ডার্টে `factory` কনস্ট্রাক্টর কী এবং কখন এটি ব্যবহার করা হয়?

**উত্তর:** `factory` কনস্ট্রাক্টর একটি নতুন ইনস্ট্যান্স তৈরি না করে একটি বিদ্যমান ইনস্ট্যান্স রিটার্ন করতে পারে। এটি ব্যবহার করা হয় যখন ইনস্ট্যান্স তৈরির প্রক্রিয়াটি জটিল হয়, বা আপনি একটি ক্যাশে থেকে বিদ্যমান ইনস্ট্যান্স ফেরত দিতে চান, অথবা সাবক্লাসের ইনস্ট্যান্স ফেরত দিতে চান। `factory` কনস্ট্রাক্টর অবশ্যই কোনো ভ্যালু রিটার্ন করবে এবং এটি `return` স্টেটমেন্ট ব্যবহার করে।

**উদাহরণ:**

```
dart
class Singleton {
  static final Singleton _instance = Singleton._internal();

  factory Singleton() {
    return _instance;
  }

  Singleton._internal();
}
```
**প্রশ্ন ৩:** ডার্টে `static` এবং ইনস্ট্যান্স ভেরিয়েবলের মধ্যে পার্থক্য কী?

**উত্তর:**

*   **ইনস্ট্যান্স ভেরিয়েবল:** এই ভেরিয়েবলগুলি ক্লাসের প্রতিটি ইনস্ট্যান্সের জন্য অনন্য। একটি ক্লাসের ইনস্ট্যান্স তৈরি করার পরেই এগুলি অ্যাক্সেস করা যায়।
*   **`static` ভেরিয়েবল:** এই ভেরিয়েবলগুলি ক্লাসের সাথে যুক্ত থাকে, কোনো নির্দিষ্ট ইনস্ট্যান্সের সাথে নয়। ক্লাসের যেকোনো ইনস্ট্যান্স বা ক্লাসের নাম ব্যবহার করে এগুলি অ্যাক্সেস করা যায়। মেমোরিতে এদের একটি মাত্র কপি থাকে।

**উদাহরণ:**
```
dart
class MyClass {
  String instanceVariable; // ইনস্ট্যান্স ভেরিয়েবল
  static String staticVariable = 'Static Value'; // static ভেরিয়েবল

  MyClass(this.instanceVariable);
}
```
**প্রশ্ন ৪:** ডার্টে `const` এবং `final` কিওয়ার্ডের মধ্যে পার্থক্য ব্যাখ্যা করুন।

**উত্তর:**

*   **`final`:** `final` ভেরিয়েবলের মান একবার সেট করার পর আর পরিবর্তন করা যায় না। কিন্তু এই মান কম্পাইল টাইমে (compile time) জানা থাকার প্রয়োজন নেই। এটি রান টাইমে (run time) সেট হতে পারে।
*   **`const`:** `const` ভেরিয়েবলের মান অবশ্যই কম্পাইল টাইমে জানা থাকতে হবে। এটি বিল্ড করার সময় স্থির থাকে এবং পরিবর্তনযোগ্য নয়। `const` ভেরিয়েবল ইম্প্লিসিটলি `final` হয়। `const` কনস্ট্রাক্টর ব্যবহার করে তৈরি করা অবজেক্টও অপরিবর্তনীয় হয়।

**উদাহরণ:**
```
dart
final name = 'Alice'; // রান টাইমে সেট হতে পারে
const int age = 30; // কম্পাইল টাইমে স্থির
```
**প্রশ্ন ৫:** ডার্টে ইভেন্ট লুপ (Event Loop) কী এবং এটি কীভাবে কাজ করে?

**উত্তর:** ইভেন্ট লুপ হলো ডার্ট রানটাইমের একটি গুরুত্বপূর্ণ অংশ যা অ্যাসিঙ্ক্রোনাস অপারেশনগুলি পরিচালনা করে। এটি একটি সিঙ্গেল-থ্রেডেড (single-threaded) মডেল ব্যবহার করে এবং দুটি কিউ (queue) থাকে:

1.  **ইভেন্ট কিউ (Event Queue):** এক্সটার্নাল ইভেন্ট যেমন I/O অপারেশন, টাইমার, ক্লিক ইত্যাদি এই কিউতে যুক্ত হয়।
2.  **মাইক্রো টাস্ক কিউ (Microtask Queue):** উচ্চ-প্রাধিকার (high-priority) অ্যাসিঙ্ক্রোনাস অপারেশন যেমন ফিউচারস (Futures)-এর `.then()` কলব্যাক এখানে যুক্ত হয়।

ইভেন্ট লুপ ক্রমাগত এই কিউ দুটি পরীক্ষা করে। প্রথমে এটি মাইক্রো টাস্ক কিউ খালি করে, তারপর ইভেন্ট কিউ থেকে একটি ইভেন্ট নেয় এবং সেটির সাথে সম্পর্কিত কোড এক্সিকিউট করে।

**প্রশ্ন ৬:** ডার্টে অ্যাসিঙ্ক্রোনাস প্রোগ্রামিংয়ে `Future` কী?

**উত্তর:** `Future` হলো একটি অবজেক্ট যা ভবিষ্যতে একটি ভ্যালু বা একটি এরর (error) প্রদান করবে। যখন আপনি একটি অ্যাসিঙ্ক্রোনাস অপারেশন শুরু করেন (যেমন নেটওয়ার্ক রিকোয়েস্ট), সেই অপারেশনটি তাৎক্ষণিকভাবে একটি `Future` অবজেক্ট রিটার্ন করে। যখন অপারেশনটি সম্পন্ন হয়, তখন `Future` হয় একটি ভ্যালু দিয়ে কমপ্লিট হয় (সফল হলে) বা একটি এরর দিয়ে কমপ্লিট হয় (ব্যর্থ হলে)।

**প্রশ্ন ৭:** ডার্টে `async` এবং `await` কিওয়ার্ডের ব্যবহার ব্যাখ্যা করুন।

**উত্তর:** `async` এবং `await` কিওয়ার্ডগুলি অ্যাসিঙ্ক্রোনাস কোডকে সহজ এবং সিনক্রোনাস-সদৃশভাবে লিখতে সাহায্য করে।

*   **`async`:** একটি ফাংশনকে অ্যাসিঙ্ক্রোনাস হিসাবে চিহ্নিত করে। একটি `async` ফাংশন সর্বদা একটি `Future` রিটার্ন করে।
*   **`await`:** শুধুমাত্র একটি `async` ফাংশনের ভেতরে ব্যবহার করা যায়। এটি একটি `Future`-এর কমপ্লিট হওয়ার জন্য অপেক্ষা করে এবং সেই `Future` থেকে প্রাপ্ত ভ্যালু রিটার্ন করে। এটি ব্লক না করে প্রোগ্রামের এক্সিকিউশন চালিয়ে যাওয়ার অনুমতি দেয়।

**উদাহরণ:**

```
dart
Future<String> fetchData() async {
  // নেটওয়ার্ক রিকোয়েস্ট বা অন্য অ্যাসিঙ্ক্রোনাস অপারেশন
  await Future.delayed(Duration(seconds: 2));
  return 'Data fetched';
}

void main() async {
  print('Fetching data...');
  String result = await fetchData();
  print(result);
}
```
**প্রশ্ন ৮:** ডার্টে `Stream` কী এবং `Future`-এর সাথে এর পার্থক্য কী?

**উত্তর:** `Stream` হলো অ্যাসিঙ্ক্রোনাস ডেটার একটি সিরিজ যা সময়ের সাথে সাথে আসে। একটি `Future` একক অ্যাসিঙ্ক্রোনাস ভ্যালু রিপ্রেজেন্ট করে, যেখানে একটি `Stream` একাধিক ভ্যালু বা এরর সরবরাহ করতে পারে সময়ের সাথে সাথে। `Stream` ব্যবহার করা হয় ডেটা স্ট্রিম হ্যান্ডেল করার জন্য, যেমন ফাইল রিডিং, নেটওয়ার্ক রিকোয়েস্ট থেকে আসা ডেটা, বা UI ইভেন্ট।

**প্রশ্ন ৯:** ডার্টে `Iterable` এবং `List`-এর মধ্যে পার্থক্য কী?

**উত্তর:**

*   **`Iterable`:** হলো একটি কালেকশন যার এলিমেন্টগুলো একে একে অ্যাক্সেস করা যায়। এটি একটি অ্যাবস্ট্রাক্ট ক্লাস এবং এর এলিমেন্টগুলো লেজি (lazy) অ্যাক্সেস প্রদান করে, যার মানে এলিমেন্টগুলো তখনই জেনারেট হয় যখন তাদের প্রয়োজন হয়।
*   **`List`:** হলো `Iterable`-এর একটি কংক্রিট ইমপ্লিমেন্টেশন। এটি অর্ডার করা এলিমেন্টগুলির একটি ফিক্সড বা গ্রোয়েবল কালেকশন। `List` র্যান্ডম অ্যাক্সেস সমর্থন করে (ইন্ডেক্স ব্যবহার করে)।

সহজ কথায়, প্রতিটি `List` একটি `Iterable` কিন্তু প্রতিটি `Iterable` একটি `List` নয়।

**প্রশ্ন ১০:** ডার্টে জেনারিকস (Generics) কেন ব্যবহার করা হয়?

**উত্তর:** জেনারিকস ব্যবহার করা হয় টাইপ সেফটি (type safety) নিশ্চিত করার জন্য এবং কোড পুনরায় ব্যবহারযোগ্যতা (reusability) বাড়ানোর জন্য। জেনারিকস আপনাকে ক্লাসে, ইন্টারফেসে, এবং মেথডে টাইপ প্যারামিটার ব্যবহার করার অনুমতি দেয়। এটি কম্পাইল টাইমে এরর ধরতে সাহায্য করে এবং রানটাইমে টাইপ কাস্টিংয়ের প্রয়োজন কমিয়ে দেয়, যা কোডকে আরও পরিষ্কার এবং ত্রুটিমুক্ত করে।

**উদাহরণ:**
