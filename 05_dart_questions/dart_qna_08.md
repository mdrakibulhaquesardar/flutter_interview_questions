## প্রশ্ন ১: Dart Isolates কী এবং কেন এটি ব্যবহার করা হয়?

**উত্তর:** Dart Isolates হলো স্বাধীন এক্সিকিউশন থ্রেড যা মেমরি শেয়ার করে না। প্রতিটি Isolate নিজস্ব মেমরি হিপ এবং ইভেন্ট লুপ নিয়ে কাজ করে। ডেটা আদান-প্রদানের জন্য তারা পোর্ট (Port) ব্যবহার করে।

**কেন ব্যবহার করা হয়:**

*   **পারফরম্যান্স:** CPU-ইনটেনসিভ টাস্কগুলি (যেমন JSON পার্সিং, ইমেজ প্রসেসিং) মেইন UI থ্রেড থেকে আলাদা করে ব্যাকগ্রাউন্ডে চালানোর জন্য Isolate ব্যবহার করা হয়। এটি UI কে ফ্রিজ হওয়া থেকে রক্ষা করে এবং অ্যাপের প্রতিক্রিয়াশীলতা উন্নত করে।
*   **ব্লকিং অপারেশন এড়ানো:** ফাইল I/O, নেটওয়ার্ক রিকোয়েস্টের মতো সম্ভাব্য ব্লকিং অপারেশনগুলি Isolate-এ চালানো যেতে পারে যাতে মেইন থ্রেড ব্লক না হয়।

**উদাহরণ:**

```
dart
import 'dart:isolate';
import 'dart:io';

void heavyComputation(SendPort sendPort) {
  // কিছু ভারী কাজ...
  int result = 0;
  for (int i = 0; i < 1000000000; i++) {
    result += i;
  }
  sendPort.send(result);
}

void main() async {
  ReceivePort receivePort = ReceivePort();
  Isolate isolate = await Isolate.spawn(heavyComputation, receivePort.sendPort);

  receivePort.listen((message) {
    print('কম্পিউটেশন শেষ: $message');
    isolate.kill(); // কাজ শেষ হলে Isolate মেরে ফেলা
  });

  print('কম্পিউটেশন চলছে...');
}
```
## প্রশ্ন ২: Dart Event Loop কী এবং কীভাবে এটি কাজ করে?

**উত্তর:** Dart একটি সিঙ্গেল-থ্রেডেড ভাষা, কিন্তু এটি অ্যাসিঙ্ক্রোনাস অপারেশন পরিচালনা করতে Event Loop ব্যবহার করে। Event Loop হলো একটি অবিরাম লুপ যা দুটি কিউ (Queue) পরিচালনা করে:

*   **Event Queue:** বাহ্যিক ইভেন্টগুলি (যেমন I/O অপারেশন শেষ হওয়া, টাইমার শেষ হওয়া, নেটওয়ার্ক রেসপন্স আসা) এই কিউতে যোগ হয়।
*   **Microtask Queue:** ছোট, দ্রুত চলমান অ্যাসিঙ্ক্রোনাস অপারেশন (যেমন `Future.then()`, `scheduleMicrotask`) এই কিউতে যোগ হয়। Microtask Queue এর কাজ Event Queue এর কাজের আগে সম্পন্ন হয়।

**কীভাবে কাজ করে:**

Event Loop প্রথমে Microtask Queue চেক করে। যদি Microtask Queue খালি না থাকে, তবে এটি Microtask Queue এর সমস্ত কাজ সম্পন্ন করে। এরপর এটি Event Queue চেক করে। যদি Event Queue খালি না থাকে, তবে এটি Queue থেকে প্রথম ইভেন্টটি নিয়ে আসে এবং তার সাথে সম্পর্কিত কোড চালায়। এই প্রক্রিয়া চলতে থাকে যতক্ষণ না উভয় কিউ খালি হয়।

## প্রশ্ন ৩: Dart এ `scheduleMicrotask` এর কাজ কী এবং এটি কখন ব্যবহার করা উচিত?

**উত্তর:** `scheduleMicrotask` হলো একটি ফাংশন যা Microtask Queue এ একটি ছোট, অ্যাসিঙ্ক্রোনাস অপারেশন যোগ করে। এই অপারেশনটি বর্তমান ইভেন্ট লুপ ইটারেশন শেষ হওয়ার আগেই, কিন্তু পরবর্তী ইভেন্ট শুরু হওয়ার আগে সম্পন্ন হবে।

**কখন ব্যবহার করা উচিত:**

*   ছোট অ্যাসিঙ্ক্রোনাস কাজগুলির জন্য যা দ্রুত সম্পন্ন হবে এবং ইভেন্ট লুপের বর্তমান ইটারেশনের মধ্যে রান করা প্রয়োজন।
*   `Future` ব্যবহার না করে immediate অ্যাসিঙ্ক্রোনাস এক্সিকিউশন প্রয়োজন হলে।
*   বিশেষ করে যখন আপনি বর্তমান কল স্ট্যাক শেষ হওয়ার পরে, কিন্তু UI আপডেট হওয়ার আগে কিছু কোড চালাতে চান।

**উদাহরণ:**

```
dart
import 'dart:async';

void main() {
  print('Start');

  scheduleMicrotask(() {
    print('Microtask 1');
  });

  Future.delayed(Duration.zero, () {
    print('Future 1 (zero delay)');
  });

  scheduleMicrotask(() {
    print('Microtask 2');
  });

  print('End');
}
```
**আউটপুট (সম্ভবত):**
Start
End
Microtask 1
Microtask 2
Future 1 (zero delay)

এখানে `Microtask 1` এবং `Microtask 2` `Future 1` এর আগে রান হয় কারণ Microtask Queue এর কাজ Event Queue এর কাজের আগে সম্পন্ন হয়, এমনকি যদি Future এর delay 0 হয়।

## প্রশ্ন ৪: Dart এ Unit Testing এবং Widget Testing এর মধ্যে পার্থক্য কী?

**উত্তর:**

*   **Unit Testing:** এটি আপনার কোডের ক্ষুদ্রতম ইউনিট (যেমন একটি ফাংশন, একটি ক্লাস) পরীক্ষা করার জন্য ব্যবহৃত হয়। এটি নিশ্চিত করে যে প্রতিটি ইউনিট স্বাধীনভাবে প্রত্যাশিতভাবে কাজ করছে। Unit test সাধারণত ফাস্ট হয় এবং কোনো UI বা Flutter ফ্রেমওয়ার্কের প্রয়োজন হয় না।
*   **Widget Testing:** এটি Flutter উইজেট পরীক্ষা করার জন্য ব্যবহৃত হয়। এটি পরীক্ষা করে যে একটি উইজেট সঠিকভাবে রেন্ডার হচ্ছে কিনা, ইউজার ইন্টারঅ্যাকশনে সঠিকভাবে প্রতিক্রিয়া জানাচ্ছে কিনা এবং তার স্টেটের পরিবর্তন সঠিকভাবে হচ্ছে কিনা। Widget test একটি টেস্ট এনভায়রনমেন্টে উইজেটকে "ইনফ্লেট" করে এবং তার উপর ইন্টারঅ্যাকশন সিমুলেট করে।

**মূল পার্থক্য:**

*   **স্কোপ:** Unit testing ক্ষুদ্র কোড ইউনিট পরীক্ষা করে, Widget testing UI কম্পোনেন্ট পরীক্ষা করে।
*   **নির্ভরশীলতা:** Unit testing-এর জন্য সাধারণত কোনো ফ্রেমওয়ার্ক বা UI পরিবেশের প্রয়োজন হয় না, Widget testing-এর জন্য Flutter টেস্টিং ফ্রেমওয়ার্ক এবং একটি টেস্ট এনভায়রনমেন্ট প্রয়োজন।
*   **স্পীড:** Unit test সাধারণত Widget test-এর চেয়ে দ্রুত হয়।

## প্রশ্ন ৫: Dart-এ Integration Testing কী এবং কেন এটি গুরুত্বপূর্ণ?

**উত্তর:** Integration Testing আপনার অ্যাপের বিভিন্ন অংশ (উইজেট, সার্ভিস, ডেটাবেস) একসাথে পরীক্ষা করার জন্য ব্যবহৃত হয়। এটি নিশ্চিত করে যে অ্যাপের বিভিন্ন কম্পোনেন্ট সঠিকভাবে একে অপরের সাথে ইন্টারঅ্যাকশন করছে।

**কেন গুরুত্বপূর্ণ:**

*   **সিস্টেমের ইন্টিগ্রিটি:** এটি নিশ্চিত করে যে আপনার অ্যাপের বিভিন্ন মডিউল বা স্ক্রীন একসাথে সঠিকভাবে কাজ করছে।
*   **এন্ড-টু-এন্ড ফ্লো:** এটি ইউজারদের অ্যাপ ব্যবহার করার সময় যে বাস্তব পরিস্থিতি তৈরি হয়, তা সিমুলেট করে পরীক্ষা করতে সাহায্য করে।
*   **ডিবাগিং সহজ করে:** যখন Integration test ফেইল করে, তখন আপনি সহজেই বুঝতে পারেন যে কোন কম্পোনেন্টগুলির মধ্যে সমস্যা হচ্ছে।

Integration test সাধারণত একটি ডিভাইসে (ফিজিক্যাল বা ইমুলেটর) বা একটি ওয়েব ব্রাউজারে রান করা হয়।

## প্রশ্ন ৬: Dart এ `covariant` কীওয়ার্ডের কাজ কী?

**উত্তর:** `covariant` কীওয়ার্ডটি মেথড ওভাররাইড করার সময় প্যারামিটারের টাইপকে "covariant" ঘোষণা করার জন্য ব্যবহৃত হয়। এর মানে হলো, আপনি সাবক্লাসে প্যারামিটারের টাইপকে সুপারক্লাসের প্যারামিটারের টাইপের সাবটাইপ দিয়ে পরিবর্তন করতে পারেন।

**কেন প্রয়োজন হয়:**

Dart একটি সাউন্ড নাল সেফটি সহ একটি সাউন্ড টাইপ সিস্টেম ব্যবহার করে। সাবক্লাসে মেথড ওভাররাইড করার সময় প্যারামিটারের টাইপ পরিবর্তন করলে টাইপ সেফটির সমস্যা হতে পারে (covariance and contravariance)। `covariant` কীওয়ার্ড কম্পাইলারকে জানায় যে আপনি সচেতনভাবে এই পরিবর্তনটি করছেন এবং টাইপ সেফটি নিশ্চিত করার দায়িত্ব আপনার।

**উদাহরণ:**

```
dart
class Animal {
  void feed(Animal food) {
    print('Feeding an animal');
  }
}

class Dog extends Animal {
  // covariant ব্যবহার না করলে এখানে টাইপ এরর হতে পারে
  @override
  void feed(covariant Bone food) {
    print('Feeding a dog a bone');
  }
}

class Bone extends Animal {}

void main() {
  Animal animal = Dog();
  // runtime error হবে যদি covariant না থাকে
  // কারণ Dog.feed expects Bone, but we are passing Animal
  animal.feed(Animal());
}
```
`covariant` ব্যবহার করে কম্পাইলার আপনাকে কম্পাইল টাইমে সতর্ক করবে না, কিন্তু রানটাইমে একটি Type error দেবে যদি আপনি ভুল টাইপের অবজেক্ট পাস করেন।

## প্রশ্ন ৭: Dart Extension Methods কী এবং কীভাবে এটি ব্যবহার করা হয়?

**উত্তর:** Extension Methods হলো Dart-এর একটি বৈশিষ্ট্য যা আপনাকে বিদ্যমান ক্লাসগুলিতে নতুন কার্যকারিতা (Methods, Getters, Setters) যোগ করতে দেয়, সেই ক্লাসগুলির সোর্স কোড পরিবর্তন না করেই।

**কীভাবে ব্যবহার করা হয়:**

একটি extension ডিফাইন করার জন্য `extension` কীওয়ার্ড ব্যবহার করা হয়, তারপর extension এর একটি নাম এবং আপনি যে টাইপের উপর extension করছেন তার নাম specify করতে হয়।

**উদাহরণ:**
```
dart
extension StringExtensions on String {
  String capitalize() {
    if (isEmpty) {
      return this;
    }
    return this[0].toUpperCase() + substring(1);
  }
}

void main() {
  String name = "flutter";
  print(name.capitalize()); // Output: Flutter
}
```
**সুবিধা:**

*   বিদ্যমান লাইব্রেরি বা SDK ক্লাসগুলিতে নতুন কার্যকারিতা যোগ করা সহজ হয়।
*   কোডকে আরও রিডেবল এবং এক্সপ্রেসিভ করে তোলে।
*   ইউটিলিটি ফাংশনগুলিকে আরও অবজেক্ট-ওরিয়েন্টেড পদ্ধতিতে সংগঠিত করা যায়।

## প্রশ্ন ৮: Dart FFI (Foreign Function Interface) কী?

**উত্তর:** Dart FFI (Foreign Function Interface) হলো Dart-এর একটি বৈশিষ্ট্য যা আপনাকে C-ভিত্তিক কোডের সাথে ইন্টারঅ্যাক্ট করতে দেয়। এর মাধ্যমে আপনি বিদ্যমান প্ল্যাটফর্ম লাইব্রেরি (যেমন অপারেটিং সিস্টেম API) বা কাস্টম C/C++ লাইব্রেরি থেকে ফাংশন কল করতে পারেন।

**কেন ব্যবহার করা হয়:**

*   **বিদ্যমান Native কোড ব্যবহার:** আপনি C, C++, বা অন্যান্য ভাষার বিদ্যমান লাইব্রেরিগুলি Flutter/Dart অ্যাপে ব্যবহার করতে পারেন।
*   **পারফরম্যান্স-ক্রিটিকাল টাস্ক:** যে কাজগুলির জন্য খুব উচ্চ পারফরম্যান্স প্রয়োজন (যেমন ইমেজ প্রসেসিং, ডেটা কমপ্রেশন), সেগুলির জন্য আপনি FFI ব্যবহার করে Native কোডে ইমপ্লিমেন্ট করতে পারেন।
*   **প্ল্যাটফর্ম-স্পেসিফিক ফিচার:** অপারেটিং সিস্টেমের নির্দিষ্ট ফিচারগুলি অ্যাক্সেস করতে যা Dart বা Flutter SDK-তে সরাসরি উপলব্ধ নয়।

FFI ব্যবহার করার জন্য Native কোড এবং Dart কোডের মধ্যে ডেটা টাইপগুলি ম্যাপ করতে হয়।

## প্রশ্ন ৯: Dart এ জেনারেটর (Generators) কী?

**উত্তর:** Dart এ জেনারেটর হলো বিশেষ ধরণের ফাংশন যা একটি সিকোয়েন্স অফ ভ্যালু রিটার্ন করে যখন সেগুলিতে অ্যাক্সেস করা হয়, পুরো সিকোয়েন্সটি একবারে মেমরিতে তৈরি না করে। এটি মেমরি এফিসিয়েন্ট হতে পারে, বিশেষ করে বড় সিকোয়েন্সের ক্ষেত্রে।

Dart এ দুই ধরণের জেনারেটর আছে:

*   **Synchronous Generators:** `sync*` কীওয়ার্ড ব্যবহার করে এবং `yield` কীওয়ার্ড দিয়ে ভ্যালু রিটার্ন করে। এটি একটি `Iterable` রিটার্ন করে।
*   **Asynchronous Generators:** `async*` কীওয়ার্ড ব্যবহার করে এবং `yield` কীওয়ার্ড দিয়ে ভ্যালু রিটার্ন করে। এটি একটি `Stream` রিটার্ন করে।

**উদাহরণ (Synchronous Generator):**

```
dart
Iterable<int> count(int n) sync* {
  for (int i = 1; i <= n; i++) {
    yield i; // প্রতিটি iterATION এ ভ্যালু রিটার্ন করে
  }
}

void main() {
  for (int i in count(5)) {
    print(i);
  }
}
```
## প্রশ্ন ১০: Dart এ মিক্সিন (Mixins) কী এবং কীভাবে এটি ব্যবহার করা হয়?

**উত্তর:** মিক্সিন হলো Dart-এর একটি উপায় কোড রিইউজের জন্য। এটি একটি ক্লাসের কোড (মেথড, ইনস্ট্যান্স ভ্যারিয়েবল) অন্য একাধিক ক্লাসে পুনরায় ব্যবহার করার অনুমতি দেয়, উত্তরাধিকার (inheritance) ব্যবহার না করেই। মিক্সিন `with` কীওয়ার্ড ব্যবহার করে একটি ক্লাসের সাথে যুক্ত করা হয়।

**কেন ব্যবহার করা হয়:**

*   **কোড রিইউজ:** একাধিক অসম্বন্ধিত ক্লাসে একই কার্যকারিতা শেয়ার করার জন্য মিক্সিন খুব দরকারী।
*   **লিমিটেড মাল্টিপল ইনহেরিটেন্স:** Dart মাল্টিপল ইনহেরিটেন্স সাপোর্ট করে না, তবে মিক্সিন অনেকটা সেই সুবিধা দেয়।

**উদাহরণ:**