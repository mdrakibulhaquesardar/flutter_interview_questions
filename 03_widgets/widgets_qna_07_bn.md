## ইন্টারভিউ প্রশ্ন ও উত্তর: Flutter Widgets (পর্ব ৬)

**প্রশ্ন ১১:** `SizedBox` এবং `Container` এর মধ্যে প্রধান পার্থক্য কী? কখন কোনটি ব্যবহার করা উচিত?

**উত্তর:**

`SizedBox` হলো একটি সহজ উইজেট যা শুধুমাত্র একটি নির্দিষ্ট আকার (প্রস্থ এবং উচ্চতা) নির্ধারণ করতে ব্যবহৃত হয়। এটি কোনো অতিরিক্ত সজ্জা (decoration), মার্জিন, প্যাডিং বা অ্যালাইনমেন্ট সরবরাহ করে না। এটি শুধুমাত্র তার চাইল্ড উইজেটের জন্য একটি নির্দিষ্ট জায়গা বরাদ্দ করে।

উদাহরণ:

```
dart
SizedBox(
  width: 100,
  height: 50,
  child: Text('Fixed Size'),
)
```
অন্যদিকে, `Container` একটি মাল্টি-পারপাস উইজেট। এটি আকার নির্ধারণের পাশাপাশি সজ্জা (decoration), মার্জিন, প্যাডিং, অ্যালাইনমেন্ট এবং ট্রান্সফরমেশনও সরবরাহ করে। এটি একটি শক্তিশালী উইজেট যা অনেক সাধারণ লেআউট এবং স্টাইলিংয়ের জন্য ব্যবহৃত হয়।

উদাহরণ:
```
dart
Container(
  width: 100,
  height: 50,
  padding: EdgeInsets.all(10),
  decoration: BoxDecoration(
    color: Colors.blue,
    borderRadius: BorderRadius.circular(10),
  ),
  alignment: Alignment.center,
  child: Text('Styled Container'),
)
```
**কখন কোনটি ব্যবহার করবেন:**

*   যখন শুধুমাত্র একটি উইজেটের আকার নির্দিষ্ট করার প্রয়োজন হয় এবং কোনো অতিরিক্ত সজ্জা বা লেআউট বৈশিষ্ট্য প্রয়োজন হয় না, তখন `SizedBox` ব্যবহার করা উচিত। এটি `Container` এর চেয়ে হালকা এবং পারফরম্যান্ট।
*   যখন আকার নির্ধারণের পাশাপাশি প্যাডিং, মার্জিন, ব্যাকগ্রাউন্ড কালার, বর্ডার, অ্যালাইনমেন্ট ইত্যাদির মতো একাধিক বৈশিষ্ট্য যোগ করার প্রয়োজন হয়, তখন `Container` ব্যবহার করা উচিত।

**প্রশ্ন ১২:** Flutter এ Implicitly Animated Widgets কী এবং কীভাবে সেগুলি কাজ করে? উদাহরণ দিন।

**উত্তর:**

Implicitly Animated Widgets হলো এক ধরণের উইজেট যা তাদের প্যারামিটারগুলির পরিবর্তন হলে স্বয়ংক্রিয়ভাবে অ্যানিমেট হয়। এর জন্য এক্সপ্লিসিট অ্যানিমেশন কন্ট্রোলার বা Ticker এর প্রয়োজন হয় না। যখন এই উইজেটগুলির একটি অ্যানিমেটেড প্রপার্টির মান পরিবর্তন হয়, তখন উইজেটটি স্বয়ংক্রিয়ভাবে নতুন মানে একটি নির্দিষ্ট সময়ের মধ্যে মসৃণভাবে ট্রানজিশন করে।

এগুলি AnimationController, Tween, AnimateBuilder ইত্যাদির মতো জটিল অ্যানিমেশন সেটআপ করার প্রয়োজন ছাড়াই সহজ অ্যানিমেশনের জন্য খুব উপযোগী।

উদাহরণ: `AnimatedContainer`, `AnimatedOpacity`, `AnimatedPositioned`, `AnimatedSwitcher` ইত্যাদি।

`AnimatedContainer` এর উদাহরণ:

```
dart
class MyAnimatedContainer extends StatefulWidget {
  @override
  _MyAnimatedContainerState createState() => _MyAnimatedContainerState();
}

class _MyAnimatedContainerState extends State<MyAnimatedContainer> {
  double _width = 50;
  double _height = 50;
  Color _color = Colors.blue;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        setState(() {
          _width = _width == 50 ? 150 : 50;
          _height = _height == 50 ? 100 : 50;
          _color = _color == Colors.blue ? Colors.red : Colors.blue;
        });
      },
      child: AnimatedContainer(
        duration: Duration(seconds: 1),
        curve: Curves.fastOutSlowIn,
        width: _width,
        height: _height,
        color: _color,
        alignment: Alignment.center,
        child: Text(
          'Tap Me',
          style: TextStyle(color: Colors.white),
        ),
      ),
    );
  }
}
```
এই উদাহরণে, `AnimatedContainer` এর `width`, `height`, এবং `color` প্রপার্টিগুলি যখন `setState` এর মাধ্যমে পরিবর্তিত হয়, তখন উইজেটটি স্বয়ংক্রিয়ভাবে ১ সেকেন্ডের মধ্যে পুরানো মান থেকে নতুন মানে অ্যানিমেট হয়।

**প্রশ্ন ১৩:** Flutter এর `Flexible` এবং `Expanded` উইজেটগুলির মধ্যে পার্থক্য কী এবং কখন সেগুলি ব্যবহার করা হয়?

**উত্তর:**

`Flexible` এবং `Expanded` উভয়ই `Row`, `Column`, এবং `Flex` উইজেটের চিলড্রেনদের জন্য ব্যবহৃত হয়। এগুলি নির্ধারণ করে যে চাইল্ড উইজেটগুলি কীভাবে তাদের প্যারেন্টের উপলব্ধ স্থান ব্যবহার করবে।

প্রধান পার্থক্য হলো:

*   **`Expanded`:** একটি `Flexible` উইজেট যার `flex` প্রপার্টির মান ১ এবং `fit` প্রপার্টির মান `FlexFit.tight` সেট করা থাকে। `Expanded` উইজেট তার প্যারেন্টের প্রধান অক্ষ বরাবর অবশিষ্ট সমস্ত স্থান পূরণ করার চেষ্টা করে। এর আকার নির্দিষ্ট করা থাকলেও, `Expanded` তাকে ওভাররাইড করে উপলব্ধ স্থান ব্যবহার করে।

*   **`Flexible`:** `Flexible` উইজেট তার প্যারেন্টের প্রধান অক্ষ বরাবর অবশিষ্ট স্থান ব্যবহার করতে পারে, তবে এটি করার জন্য বাধ্য নয়। এর `fit` প্রপার্টি `FlexFit.tight` (`Expanded` এর মতো) বা `FlexFit.loose` হতে পারে।
    *   `FlexFit.tight`: চাইল্ডকে প্যারেন্টের উপলব্ধ স্থান পূরণ করার জন্য বাধ্য করে (এটি `Expanded` এর সমতুল্য)।
    *   `FlexFit.loose`: চাইল্ডকে তার নিজের আকারের মধ্যে থেকে প্যারেন্টের উপলব্ধ স্থান ব্যবহার করার অনুমতি দেয়, তবে পুরো স্থান ব্যবহার করার জন্য বাধ্য করে না।

**কখন কোনটি ব্যবহার করবেন:**

*   আপনি যখন চান একটি উইজেট তার প্যারেন্টের প্রধান অক্ষ বরাবর অবশিষ্ট সমস্ত স্থান ব্যবহার করুক, তখন `Expanded` ব্যবহার করুন। এটি সাধারণত একটি `Row` বা `Column` এ একাধিক উইজেটের মধ্যে উপলব্ধ স্থান সমানভাবে বন্টন করতে ব্যবহৃত হয়।
*   আপনি যখন চান একটি উইজেট তার প্যারেন্টের প্রধান অক্ষ বরাবর অবশিষ্ট স্থান ব্যবহার করতে পারে, কিন্তু তার নিজের আকারের মধ্যে সীমাবদ্ধ থাকতে পারে, তখন `Flexible` ব্যবহার করুন। আপনি `fit` প্রপার্টি ব্যবহার করে নিয়ন্ত্রণ করতে পারেন যে উইজেটটি কতটা স্থান ব্যবহার করবে।

**প্রশ্ন ১৪:** Flutter এর Widget Tree, Element Tree এবং Render Tree এর মধ্যে সম্পর্ক ব্যাখ্যা করুন।

**উত্তর:**

Flutter এর রেন্ডারিং প্রক্রিয়া তিনটি প্রধান গাছের (Tree) উপর নির্ভর করে:

1.  **Widget Tree:** এটি অ্যাপ্লিকেশন UI এর কনফিগারেশন বর্ণনা করে। প্রতিটি উইজেট হলো UI এর একটি অংশ কিভাবে দেখা উচিত তার একটি ইম্মিউটেবল বর্ণনা। এটি সবচেয়ে হালকা গাছ এবং ঘন ঘন পুনর্নির্মাণ করা হয়। যখন উইজেট ট্রি পরিবর্তিত হয়, Flutter Element Tree আপডেট করার জন্য এটি ব্যবহার করে।

2.  **Element Tree:** এটি উইজেট ট্রি এবং রেন্ডার ট্রি এর মধ্যে একটি মধ্যস্থতাকারী স্তর। এটি UI এর স্ট্রাকচারের একটি মিউটেবল প্রতিনিধিত্ব। প্রতিটি এলিমেন্ট একটি নির্দিষ্ট উইজেটের একটি ইনস্ট্যান্স এবং রেন্ডার ট্রিতে সংশ্লিষ্ট রেন্ডার অবজেক্টের লিঙ্ক ধারণ করে। যখন উইজেট ট্রি পরিবর্তিত হয়, Flutter একই ধরণের বিদ্যমান এলিমেন্টগুলি পুনঃব্যবহার করে Element Tree আপডেট করে, যা পারফরম্যান্স উন্নত করে।

3.  **Render Tree:** এটি UI এর লেআউট এবং পেইন্টিং লজিক ধারণ করে। প্রতিটি রেন্ডার অবজেক্ট স্ক্রিনে কিভাবে আঁকা হবে (যেমন আকার, অবস্থান, রঙ ইত্যাদি) তা নির্ধারণ করে। Element Tree থেকে তথ্য ব্যবহার করে Render Tree আপডেট করা হয়। এই গাছটি UI উপাদানগুলির দৃশ্যমান উপস্থাপনার জন্য দায়ী।

**সম্পর্ক:**

*   Widget Tree Element Tree এর কনফিগারেশন সরবরাহ করে।
*   Element Tree Render Tree তৈরি এবং আপডেট করার জন্য দায়ী।
*   Render Tree UI এর ভিজ্যুয়াল উপস্থাপনা স্ক্রিনে আঁকে।

সহজভাবে বলতে গেলে, Widget Tree কী আঁকতে হবে তা বর্ণনা করে, Element Tree কার্যকরভাবে এটি পরিচালনা করে, এবং Render Tree আসলে এটি স্ক্রিনে আঁকে।

**প্রশ্ন ১৫:** Flutter এ Key এর গুরুত্ব কী এবং কখন সেগুলি ব্যবহার করা উচিত?

**উত্তর:**

Flutter এ Keyগুলি উইজেট, এলিমেন্ট এবং সেগুলির স্টেট সনাক্ত করতে ব্যবহৃত হয়। যখন Flutter উইজেট ট্রি পুনর্নির্মাণ করে, তখন এটি বিদ্যমান এলিমেন্ট ট্রি এর সাথে নতুন উইজেট ট্রি তুলনা করে। Key ব্যবহার করে, Flutter একই ধরণের উইজেটগুলির মধ্যে মিল খুঁজে বের করতে পারে, এমনকি যদি তাদের ট্রি অবস্থানে পরিবর্তন হয়।

Key ব্যবহার করলে Flutter এলিমেন্ট এবং সেগুলির সংশ্লিষ্ট স্টেট সঠিকভাবে পুনঃব্যবহার করতে পারে, অপ্রয়োজনীয় পুনর্নির্মাণ এবং স্টেট হারানোর ঝুঁকি কমায়।

**কখন Key ব্যবহার করা উচিত:**

*   **সমজাতীয় (Homogeneous) তালিকা:** যখন আপনার একটি তালিকা (যেমন `ListView`, `Column`, `Row`) থাকে যেখানে একই ধরণের উইজেটের একাধিক ইনস্ট্যান্স রয়েছে (যেমন একটি কাস্টম তালিকা আইটেম উইজেট) এবং আপনি তালিকাটি শর্ট বা পুনর্বিন্যাস করতে পারেন। Key ব্যবহার করলে Flutter প্রতিটি আইটেমকে সঠিকভাবে সনাক্ত করতে পারবে এবং তাদের স্টেট বজায় রাখতে পারবে।
*   **ডায়নামিকভাবে যুক্ত বা অপসারিত উইজেট:** যখন আপনি ডায়নামিকভাবে উইজেট যোগ বা অপসারণ করেন এবং আপনি সেগুলির স্টেট বজায় রাখতে চান।
*   **একই ধরণের একাধিক উইজেটের মধ্যে স্টেট বজায় রাখা:** যখন আপনার একই প্যারেন্টের অধীনে একই ধরণের একাধিক উইজেট থাকে এবং আপনি তাদের মধ্যে স্টেট কনফ্লিক্ট এড়াতে চান।

**বিভিন্ন ধরণের Key:**

*   **`ValueKey`:** একটি মান (যেমন স্ট্রিং, ইন্টিজার) ব্যবহার করে উইজেট সনাক্ত করে।
*   **`ObjectKey`:** একটি অবজেক্ট ব্যবহার করে উইজেট সনাক্ত করে।
*   **`UniqueKey`:** প্রতিটি অ্যাপ রিস্টার্টের জন্য একটি অনন্য কী তৈরি করে।
*   **`PageStorageKey`:** স্ক্রোল পজিশনের মতো পেজ-নির্দিষ্ট স্টেট বজায় রাখতে ব্যবহৃত হয়।

সাধারণত, আপনি যখন একটি উইজেটের স্টেটকে তার অবস্থানের পরিবর্তে তার বিষয়বস্তুর সাথে যুক্ত করতে চান তখন Key ব্যবহার করা সবচেয়ে গুরুত্বপূর্ণ।

**প্রশ্ন ১৬:** Flutter এ Hero অ্যানিমেশন কী এবং কীভাবে এটি বাস্তবায়ন করা হয়?

**উত্তর:**

Hero অ্যানিমেশন হলো এক ধরণের ট্রানজিশন অ্যানিমেশন যা দুটি স্ক্রিনের মধ্যে একটি সাধারণ উইজেটকে (সাধারণত একটি ছবি) মসৃণভাবে উড়ে যেতে দেখায়। এটি সাধারণত একটি তালিকা স্ক্রিন থেকে একটি ডিটেইল স্ক্রিনে নেভিগেট করার সময় ব্যবহৃত হয়, যেখানে তালিকা আইটেমের একটি ছবি ডিটেইল স্ক্রিনে বড় আকারে প্রদর্শিত হয়।

Hero অ্যানিমেশন দুটি উইজেটের মধ্যে একটি "ফ্লাইং" অ্যানিমেশন তৈরি করে:

1.  **Source Hero:** প্রথম স্ক্রিনের উইজেট যা অ্যানিমেশনের শুরু বিন্দু।
2.  **Destination Hero:** দ্বিতীয় স্ক্রিনের উইজেট যা অ্যানিমেশনের শেষ বিন্দু।

এই দুটি Hero উইজেটকে একই `tag` দিয়ে চিহ্নিত করতে হবে। যখন আপনি এক স্ক্রিন থেকে অন্য স্ক্রিনে নেভিগেট করেন, Flutter স্বয়ংক্রিয়ভাবে একই `tag` সহ Hero উইজেটগুলির মধ্যে মসৃণ অ্যানিমেশন তৈরি করে।

**বাস্তবায়ন:**

Hero অ্যানিমেশন বাস্তবায়ন করা খুব সহজ। আপনাকে কেবল দুটি স্ক্রিনের সাধারণ উইজেটগুলিকে `Hero` উইজেটের মধ্যে র্যাপ করতে হবে এবং উভয় `Hero` উইজেটকে একটি অনন্য `tag` সরবরাহ করতে হবে।

উদাহরণ:

স্ক্রিন 1 (লিস্ট স্ক্রিন):

```
dart
ListView.builder(
  itemCount: items.length,
  itemBuilder: (context, index) {
    final item = items[index];
    return ListTile(
      leading: Hero(
        tag: item.id, // অনন্য ট্যাগ
        child: Image.network(item.imageUrl),
      ),
      title: Text(item.name),
      onTap: () {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => DetailScreen(item: item),
          ),
        );
      },
    );
  },
)
```
স্ক্রিন 2 (ডিটেইল স্ক্রিন):
```
dart
class DetailScreen extends StatelessWidget {
  final Item item;

  DetailScreen({required this.item});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(item.name)),
      body: Center(
        child: Hero(
          tag: item.id, // অবশ্যই একই ট্যাগ
          child: Image.network(item.imageUrl),
        ),
      ),
    );
  }
}
```
এই উদাহরণে, যখন একটি `ListTile` ট্যাপ করা হয়, তখন নেভিগেশন ঘটে এবং একই `item.id` ট্যাগ সহ `Hero` উইজেটগুলির মধ্যে একটি মসৃণ অ্যানিমেশন দেখা যায়।

**প্রশ্ন ১৭:** Flutter এ RenderObject কী এবং এর ভূমিকা কী?

**উত্তর:**

RenderObject হলো Flutter এর রেন্ডারিং পাইপলাইনের একটি মৌলিক অংশ। এটি একটি অ্যাবসট্রাক্ট ক্লাস যা UI এলিমেন্টের লেআউট এবং পেইন্টিং লজিক বর্ণনা করে। উইজেট ট্রি এবং এলিমেন্ট ট্রি UI এর কনফিগারেশন ধরে রাখে, কিন্তু RenderObject ট্রি আসলে UI কিভাবে স্ক্রিনে দেখা যাবে তা নির্ধারণ করে।

প্রতিটি এলিমেন্টের একটি সংশ্লিষ্ট RenderObject থাকতে পারে (তবে সবসময় থাকে না)। RenderObject ট্রি এলিমেন্ট ট্রি থেকে তৈরি হয় এবং লেআউট এবং পেইন্টিং পর্যায়ে ব্যবহৃত হয়।

**RenderObject এর ভূমিকা:**

*   **Layout:** RenderObject তার চিলড্রেনদের অবস্থান এবং আকার গণনা করে। এটি প্যারেন্ট RenderObject দ্বারা সরবরাহ করা constraints এর উপর ভিত্তি করে এটি করে।
*   **Painting:** RenderObject কিভাবে স্ক্রিনে আঁকা হবে (যেমন আকার, রঙ, টেক্সট, ছবি ইত্যাদি) তা নির্ধারণ করে। এটি `Canvas` অবজেক্টে প্রয়োজনীয় ড্রয়িং অপারেশন করে।
*   **Hit Testing:** এটি নির্ধারণ করে যে ব্যবহারকারীর ইনপুট (যেমন ট্যাপ) কোন RenderObject এ লেগেছে।

RenderObjectগুলি তুলনামূলকভাবে ভারী অবজেক্ট এবং সরাসরি ম্যানিপুলেট করা সাধারণত প্রয়োজন হয় না। Flutter ফ্রেমওয়ার্ক এলিমেন্ট ট্রি থেকে RenderObject ট্রি তৈরি এবং আপডেট করার কাজটি পরিচালনা করে। কাস্টম রেন্ডারিং প্রয়োজন হলে `CustomPainter` বা সরাসরি `RenderObject` ক্লাসের সাবক্লাস তৈরি করে কাজ করা যেতে পারে।

**প্রশ্ন ১৮:** Flutter এ Slivers কী এবং কখন সেগুলি ব্যবহার করা হয়?

**উত্তর:**

Slivers হলো স্ক্রোলযোগ্য অঞ্চলের (Scrollable regions) একটি ছোট অংশ যা স্ক্রোলিং ইফেক্ট বাস্তবায়নের জন্য ব্যবহার করা যেতে পারে। তারা সাধারণত `CustomScrollView` এর সাথে ব্যবহৃত হয়। স্ট্যান্ডার্ড স্ক্রোলযোগ্য উইজেট (যেমন `ListView`, `GridView`) ভিউপোর্টের বাইরেও তাদের সমস্ত চিলড্রেনদের লেআউট তৈরি করে, যা পারফরম্যান্স সমস্যা তৈরি করতে পারে যদি চিলড্রেনদের সংখ্যা খুব বেশি হয়।

Slivers শুধুমাত্র ভিউপোর্টের মধ্যে বা তার কাছাকাছি থাকা আইটেমগুলির লেআউট তৈরি করে, যা বৃহৎ তালিকা বা গ্রিডের জন্য পারফরম্যান্স উন্নত করে।

**Slivers এর ব্যবহার:**

Slivers বিভিন্ন ধরণের কাস্টম স্ক্রোলিং ইফেক্ট তৈরি করতে ব্যবহার করা যেতে পারে, যেমন:

*   **Shrinking/Expanding App Bars:** স্ক্রোল করার সময় অ্যাপ বারের আকার পরিবর্তন করা।
*   **Pinned Headers:** স্ক্রোল করার সময় কিছু হেডারকে স্ক্রিনের উপরে আটকে রাখা।
*   **Lists and Grids with Custom Layouts:** বিভিন্ন ধরণের তালিকা বা গ্রিড আইটেম সহ স্ক্রোলযোগ্য অঞ্চল তৈরি করা।
*   **Parallax Effects:** স্ক্রোল করার সময় ব্যাকগ্রাউন্ড ইমেজ বা অন্যান্য উপাদানগুলির গতির পার্থক্য তৈরি করা।

**সাধারণ Slivers:**

*   `SliverAppBar`: একটি অ্যাপ বার যা স্ক্রোল করার সময় কলাপ্স বা এক্সপ্যান্ড হতে পারে।
*   `SliverList`: একটি স্ট্যান্ডার্ড তালিকা যা শুধুমাত্র ভিউপোর্টের মধ্যে থাকা আইটেমগুলির লেআউট তৈরি করে।
*   `SliverGrid`: একটি স্ট্যান্ডার্ড গ্রিড যা শুধুমাত্র ভিউপোর্টের মধ্যে থাকা আইটেমগুলির লেআউট তৈরি করে।
*   `SliverToBoxAdapter`: একটি স্ট্যান্ডার্ড উইজেট (যেমন `Container`, `Text`) কে `CustomScrollView` এর মধ্যে ব্যবহার করার অনুমতি দেয়।

**কখন Slivers ব্যবহার করবেন:**

*   যখন আপনার একটি কাস্টম স্ক্রোলিং ইফেক্ট তৈরি করার প্রয়োজন হয় যা স্ট্যান্ডার্ড `ListView` বা `GridView` দিয়ে সহজে করা যায় না।
*   যখন আপনার বৃহৎ তালিকা বা গ্রিড থাকে এবং আপনি পারফরম্যান্স উন্নত করতে চান শুধুমাত্র ভিউপোর্টের মধ্যে থাকা আইটেমগুলির লেআউট তৈরি করে।

**প্রশ্ন ১৯:** Flutter এ GlobalKey কী এবং LocalKey থেকে এর পার্থক্য কী?

**উত্তর:**

Flutter এ Keyগুলি উইজেট, এলিমেন্ট এবং সেগুলির স্টেট সনাক্ত করতে ব্যবহৃত হয়। Key দুই ধরণের হয়: LocalKey এবং GlobalKey।

*   **LocalKey:** এটি একটি প্যারেন্ট উইজেটের মধ্যে তার siblings (একই প্যারেন্টের চিলড্রেন) এর মধ্যে উইজেটকে সনাক্ত করতে ব্যবহৃত হয়। এটি শুধুমাত্র তার নিকটতম প্যারেন্টের স্কোপের মধ্যে অনন্য হতে হবে। `ValueKey`, `ObjectKey`, এবং `UniqueKey` হলো LocalKey এর উদাহরণ।

*   **GlobalKey:** এটি সম্পূর্ণ অ্যাপ্লিকেশন জুড়ে একটি উইজেট এবং তার সংশ্লিষ্ট এলিমেন্ট এবং স্টেট সনাক্ত করতে ব্যবহৃত হয়। এটি অ্যাপ্লিকেশন জুড়ে অনন্য হতে হবে। GlobalKey ব্যবহার করে আপনি ট্রি তে যেকোনো জায়গা থেকে একটি নির্দিষ্ট উইজেট বা তার স্টেটে অ্যাক্সেস করতে পারেন।

**GlobalKey এর ব্যবহার:**

*   **অন্য উইজেট থেকে একটি উইজেটের স্টেট অ্যাক্সেস করা:** উদাহরণস্বরূপ, একটি ফর্ম উইজেটের স্টেট অ্যাক্সেস করে ফর্মটি ভ্যালিডেট করার জন্য `GlobalKey<FormState>` ব্যবহার করা হয়।
*   **ন্যাভিগেশন স্টেট অ্যাক্সেস করা:** `GlobalKey<NavigatorState>` ব্যবহার করে নেভিগেটর স্টেট অ্যাক্সেস করা এবং প্রোগ্রাম্যাটিকভাবে নেভিগেট করা যায়।
*   **একটি উইজেটের আকার বা অবস্থান পরিমাপ করা:** `GlobalKey` ব্যবহার করে একটি উইজেটের `RenderObject` অ্যাক্সেস করা যায় এবং তার আকার বা অবস্থান সম্পর্কে তথ্য পাওয়া যায়।

**পার্থক্য:**

| বৈশিষ্ট্য      | LocalKey                                  | GlobalKey                                       |
| :------------ | :---------------------------------------- | :---------------------------------------------- |
| স্কোপ         | প্যারেন্টের siblings এর মধ্যে অনন্য        | সম্পূর্ণ অ্যাপ্লিকেশন জুড়ে অনন্য                 |
| অ্যাক্সেস      | শুধুমাত্র প্যারেন্ট দ্বারা বা তার নিকটবর্তী | ট্রি তে যেকোনো জায়গা থেকে অ্যাক্সেসযোগ্য      |
| ব্যবহার        | সমজাতীয় তালিকার আইটেম, ডায়নামিক উইজেট | স্টেট অ্যাক্সেস, নেভিগেশন, আকার পরিমাপ ইত্যাদি |

GlobalKey ব্যবহার করার সময় সতর্ক থাকা উচিত কারণ এটি ট্রি তে একটি রেফারেন্স ধারণ করে এবং মেমরি লিক ঘটাতে পারে যদি সঠিকভাবে ব্যবহার না করা হয়। যখন সম্ভব LocalKey ব্যবহার করা উচিত।

**প্রশ্ন ২০:** Flutter এ CustomPainter কী এবং এটি কীভাবে ব্যবহৃত হয়?

**উত্তর:**

`CustomPainter` হলো Flutter এ কাস্টম ২ডি গ্রাফিক্স আঁকার জন্য ব্যবহৃত একটি ক্লাস। এটি একটি `CustomPaint` উইজেটের সাথে ব্যবহৃত হয়। যখন আপনার UI তে এমন কিছু আঁকার প্রয়োজন হয় যা বিদ্যমান উইজেটগুলির সাথে সহজে করা যায় না (যেমন কাস্টম শেপ, গ্রাফ, ডায়াগ্রাম), তখন `CustomPainter` ব্যবহার করা হয়।

`CustomPainter` অ্যাবসট্রাক্ট ক্লাসের দুটি প্রধান মেথড রয়েছে যা আপনাকে ওভাররাইড করতে হবে:

1.  **`paint(Canvas canvas, Size size)`:** এই মেথডটি যেখানে আপনি আপনার কাস্টম ড্রয়িং লজিক লিখবেন। `canvas` অবজেক্ট ব্যবহার করে আপনি লাইন, সার্কেল, রেকট্যাঙ্গেল, পাথ ইত্যাদি আঁকতে পারেন। `size` প্যারামিটার `CustomPaint` উইজেটের আকার নির্দেশ করে।
2.  **`shouldRepaint(covariant CustomPainter oldDelegate)`:** এই মেথডটি নির্ধারণ করে যে উইজেটটি পুনরায় আঁকা উচিত কিনা যখন delegate অবজেক্ট পরিবর্তিত হয়। যদি `true` রিটার্ন করে, তবে `paint` মেথড আবার কল করা হবে। পারফরম্যান্সের জন্য, যখন প্রয়োজন তখনই `true` রিটার্ন করা গুরুত্বপূর্ণ।

**ব্যবহার:**

একটি কাস্টম পেইন্টার তৈরি করতে, আপনাকে `CustomPainter` অ্যাবসট্রাক্ট ক্লাসের একটি সাবক্লাস তৈরি করতে হবে এবং `paint` এবং `shouldRepaint` মেথডগুলি ওভাররাইড করতে হবে। তারপর এই কাস্টম পেইন্টার অবজেক্টটি একটি `CustomPaint` উইজেটের `painter` প্রপার্টিতে সরবরাহ করতে হবে।

উদাহরণ:

```
dart
class MyCustomPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.blue
      ..strokeWidth = 5;

    // একটি লাইন আঁকা
    canvas.drawLine(
      Offset(0, 0),
      Offset(size.width, size.height),
      paint,
    );

    // একটি বৃত্ত আঁকা
    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      size.minDimension / 4,
      paint..color = Colors.red, // রং পরিবর্তন
    );
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return false; // যদি পেইন্টিং ডেটা পরিবর্তন না হয়, তবে false রিটার্ন করুন
  }
}

class MyWidgetWithCustomPaint extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      painter: MyCustomPainter(),
      child: Container(), // বা চাইল্ড উইজেট যা ক্যানভাসের উপরে থাকবে
    );
  }
}
```
এই উদাহরণে, `MyCustomPainter` একটি লাইন এবং একটি বৃত্ত আঁকছে। `MyWidgetWithCustomPaint` উইজেটটি এই পেইন্টার ব্যবহার করে কাস্টম গ্রাফিক্স প্রদর্শন করে। `CustomPainter` ক্যানভাসে সরাসরি আঁকার জন্য শক্তিশালী নিয়ন্ত্রণ সরবরাহ করে, যা জটিল ভিজ্যুয়াল তৈরির জন্য অপরিহার্য।