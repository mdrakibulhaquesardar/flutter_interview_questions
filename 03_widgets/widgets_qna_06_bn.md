## ইন্টারভিউ প্রশ্ন ও উত্তর: Flutter Widgets (পর্ব ৫)

এই পর্বে Flutter Widgets সম্পর্কিত আরও ১০টি গুরুত্বপূর্ণ প্রশ্ন ও উত্তর আলোচনা করা হলো।

**প্রশ্ন ১১: Expanded এবং Flexible উইজেটের মধ্যে পার্থক্য কী?**

**উত্তর:** `Expanded` এবং `Flexible` উভয়ই `Row`, `Column`, এবং `Flex` উইজেটের চাইল্ড হিসেবে ব্যবহৃত হয় তাদের চাইল্ডকে উপলব্ধ স্থানের মধ্যে ফ্লেক্সিবলভাবে প্রসারিত করতে।

*   **`Expanded`:** এটি তার চাইল্ডকে উপলব্ধ স্থানের পুরোটুকু ব্যবহার করতে বাধ্য করে। `Expanded` একটি `flex` প্রপার্টি নেয়, যা নির্দেশ করে যে উপলব্ধ স্থান কীভাবে বিভিন্ন `Expanded` উইজেটের মধ্যে ভাগ করা হবে। ডিফল্ট `flex` ভ্যালু হলো 1।
*   **`Flexible`:** এটি তার চাইল্ডকে উপলব্ধ স্থানের মধ্যে প্রসারিত হওয়ার অনুমতি দেয়, কিন্তু বাধ্য করে না। `Flexible` এর দুটি প্রধান `fit` প্রপার্টি আছে: `FlexFit.tight` (যা `Expanded` এর মতো কাজ করে) এবং `FlexFit.loose` (যা চাইল্ডকে তার নিজস্ব মাপের মধ্যে সীমাবদ্ধ থাকতে দেয়)।

সহজ কথায়, `Expanded` সবসময় Fill করে, আর `Flexible` Fill করতেও পারে আবার নাও করতে পারে, তার `fit` প্রপার্টির উপর নির্ভর করে।

**প্রশ্ন ১২: Opacity উইজেট কীভাবে কাজ করে এবং কখন এটি ব্যবহার করা উচিত?**

**উত্তর:** `Opacity` উইজেট তার চাইল্ডের স্বচ্ছতা (opacity) নিয়ন্ত্রণ করতে ব্যবহৃত হয়। এটি `opacity` নামক একটি ডাবল (double) ভ্যালু নেয়, যার মান 0.0 (সম্পূর্ণ স্বচ্ছ) থেকে 1.0 (সম্পূর্ণ অস্বচ্ছ) এর মধ্যে থাকে।

এটি সাধারণত কোনো উইজেটকে ধীরে ধীরে অদৃশ্য বা দৃশ্যমান করার জন্য বা কোনো এলিমেন্টকে আংশিকভাবে স্বচ্ছ দেখানোর জন্য ব্যবহৃত হয়। পারফরম্যান্সের জন্য, ছোট উইজেটের জন্য `Opacity` ব্যবহার করা ভালো। বড় উইজেটের জন্য বা ঘন ঘন অপাসিটি পরিবর্তন করার প্রয়োজন হলে `FadeTransition` বা `AnimatedOpacity` ব্যবহার করা যেতে পারে, কারণ `Opacity` উইজেট প্রতিটি রেন্ডারিং ফ্রেমে একটি অফস্ক্রিন বাফার তৈরি করতে পারে যা পারফরম্যান্সে প্রভাব ফেলতে পারে।

```
dart
Opacity(
  opacity: 0.5, // 50% স্বচ্ছ
  child: Container(
    color: Colors.blue,
    width: 100,
    height: 100,
  ),
)
```
**প্রশ্ন ১৩: Stack উইজেট কী এবং এর ব্যবহার কী?**

**উত্তর:** `Stack` উইজেট একাধিক উইজেটকে একে অপরের উপরে স্ট্যাক করার জন্য ব্যবহৃত হয়, অনেকটা কাগজ স্তূপ করার মতো। `Stack` উইজেটের চাইল্ডগুলি একে অপরের উপরে লেয়ার হিসেবে প্রদর্শিত হয়, প্রথম চাইল্ডটি সবার নিচে এবং শেষ চাইল্ডটি সবার উপরে থাকে।

এটি সাধারণত উইজেটগুলির উপরে ওভারলে তৈরি করতে ব্যবহৃত হয়, যেমন ছবির উপরে টেক্সট বা আইকন যোগ করা। `Positioned` উইজেট `Stack` এর মধ্যে চাইল্ডদের নির্দিষ্ট অবস্থানে রাখার জন্য ব্যবহৃত হয়।
```
dart
Stack(
  children: <Widget>[
    Container(
      color: Colors.red,
      width: 200,
      height: 200,
    ),
    Positioned(
      bottom: 10,
      right: 10,
      child: Text(
        'Overlay Text',
        style: TextStyle(color: Colors.white),
      ),
    ),
  ],
)
```
**প্রশ্ন ১৪: Positioned উইজেটের কাজ কী এবং এটি কোন উইজেটের সাথে ব্যবহৃত হয়?**

**উত্তর:** `Positioned` উইজেট `Stack` উইজেটের চাইল্ড হিসেবে ব্যবহৃত হয়। এটি `Stack` এর মধ্যে তার চাইল্ড উইজেটের অবস্থান নির্দিষ্ট করার জন্য `top`, `bottom`, `left`, এবং `right` প্রপার্টি ব্যবহার করে। এই প্রপার্টিগুলি `Stack` এর কিনারা থেকে উইজেটের দূরত্ব নির্ধারণ করে।

এটি ফ্লোটিং বা নির্দিষ্ট অবস্থানে উইজেট রাখার জন্য খুবই উপযোগী।
```
dart
Stack(
  children: <Widget>[
    Container(
      color: Colors.yellow,
      width: double.infinity,
      height: double.infinity,
    ),
    Positioned(
      top: 50,
      left: 50,
      child: Container(
        color: Colors.green,
        width: 50,
        height: 50,
      ),
    ),
  ],
)
```
**প্রশ্ন ১৫: FutureBuilder উইজেট কী এবং এর ব্যবহার কী?**

**উত্তর:** `FutureBuilder` উইজেট একটি `Future` এর সাথে কাজ করে। এটি একটি `Future` এর বর্তমান অবস্থার (যেমন, ডেটা লোডিং হচ্ছে, ডেটা পাওয়া গেছে, বা একটি ত্রুটি ঘটেছে) উপর ভিত্তি করে UI তৈরি করে।

এটি সাধারণত অ্যাসিঙ্ক্রোনাস অপারেশন (যেমন নেটওয়ার্ক কল, ডেটাবেস থেকে ডেটা লোড করা) থেকে প্রাপ্ত ডেটা ব্যবহার করে UI আপডেট করার জন্য ব্যবহৃত হয়। `FutureBuilder` এর `builder` ফাংশন একটি `AsyncSnapshot` অবজেক্ট পায়, যা `Future` এর অবস্থা এবং ডেটা ধারণ করে।
```
dart
FutureBuilder<String>(
  future: fetchUserData(), // ধরুন fetchUserData একটি Future<String> রিটার্ন করে
  builder: (BuildContext context, AsyncSnapshot<String> snapshot) {
    if (snapshot.connectionState == ConnectionState.waiting) {
      return CircularProgressIndicator(); // ডেটা লোডিং হচ্ছে
    } else if (snapshot.hasError) {
      return Text('Error: ${snapshot.error}'); // কোনো ত্রুটি ঘটেছে
    } else {
      return Text('User Data: ${snapshot.data}'); // ডেটা পাওয়া গেছে
    }
  },
)
```
**প্রশ্ন ১৬: StreamBuilder উইজেট কী এবং এটি কখন ব্যবহার করা হয়?**

**উত্তর:** `StreamBuilder` উইজেট একটি `Stream` এর সাথে কাজ করে। এটি একটি `Stream` থেকে নির্গত হওয়া ডেটা শুনে এবং সেই ডেটার উপর ভিত্তি করে UI আপডেট করে। যখনই `Stream` নতুন ডেটা নির্গত করে, `StreamBuilder` স্বয়ংক্রিয়ভাবে রি-বিল্ড হয়।

এটি রিয়েল-টাইম ডেটা (যেমন চ্যাট মেসেজ, স্টক আপডেট) বা ডেটার স্ট্রীমের উপর ভিত্তি করে UI আপডেট করার জন্য ব্যবহৃত হয়। `StreamBuilder` এর `builder` ফাংশন একটি `AsyncSnapshot` অবজেক্ট পায়, যা `Stream` এর সর্বশেষ ডেটা ধারণ করে।
```
dart
StreamBuilder<int>(
  stream: countStream(), // ধরুন countStream একটি Stream<int> রিটার্ন করে
  builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
    if (snapshot.hasData) {
      return Text('Count: ${snapshot.data}');
    } else {
      return Text('Waiting for data...');
    }
  },
)
```
**প্রশ্ন ১৭: GestureDetector উইজেট কী এবং এর সাধারণ ব্যবহারগুলি কী কী?**

**উত্তর:** `GestureDetector` উইজেট একটি উইজেটে ইউজার ইন্টারঅ্যাকশন (যেমন ট্যাপ, ডাবল ট্যাপ, লং প্রেস, ড্র্যাগ, স্ক্রোল) সনাক্ত করতে ব্যবহৃত হয়। এটি বিভিন্ন কলব্যাক ফাংশন সরবরাহ করে যা নির্দিষ্ট অঙ্গভঙ্গি সনাক্ত হলে ট্রিগার হয়।

এটি উইজেটকে ইন্টারেক্টিভ করার জন্য অত্যন্ত গুরুত্বপূর্ণ, যেমন বোতামে ট্যাপ যোগ করা বা উইজেটকে ড্র্যাগ করার অনুমতি দেওয়া।
```
dart
GestureDetector(
  onTap: () {
    print('Tapped!');
  },
  onDoubleTap: () {
    print('Double Tapped!');
  },
  child: Container(
    color: Colors.teal,
    width: 100,
    height: 100,
    child: Center(child: Text('Tap Me')),
  ),
)
```
**প্রশ্ন ১৮: AbsorbPointer এবং IgnorePointer উইজেটের মধ্যে পার্থক্য কী?**

**উত্তর:** উভয় উইজেটই তার চাইল্ড উইজেটগুলিতে পয়েন্টার ইভেন্ট (যেমন ট্যাপ, ড্র্যাগ) ব্লক করতে ব্যবহৃত হয়।

*   **`AbsorbPointer`:** এটি তার চাইল্ডগুলিতে পয়েন্টার ইভেন্ট শোষণ করে নেয়, যার ফলে চাইল্ডগুলিতে কোনো ইভেন্ট পৌঁছায় না। তবে, `AbsorbPointer` নিজেই ইভেন্টগুলি গ্রহণ করতে পারে (যদি এর নিজস্ব `onTap` বা অন্যান্য অঙ্গভঙ্গি হ্যান্ডলার থাকে)।
*   **`IgnorePointer`:** এটি তার চাইল্ডগুলিতে পয়েন্টার ইভেন্টগুলি উপেক্ষা করে এবং সেগুলিকে নিচের উইজেটে পাঠিয়ে দেয়। `IgnorePointer` নিজেই কোনো পয়েন্টার ইভেন্ট গ্রহণ করে না।

সহজ কথায়, `AbsorbPointer` ইভেন্ট গ্রহণ করে কিন্তু চাইল্ডে যেতে দেয় না, আর `IgnorePointer` ইভেন্ট সম্পূর্ণ উপেক্ষা করে এবং নিচে পাঠিয়ে দেয়।

**প্রশ্ন ১৯: Hero উইজেট কী এবং এটি কীভাবে কাজ করে?**

**উত্তর:** `Hero` উইজেট দুটি ভিন্ন স্ক্রীনের মধ্যে একটি উইজেটকে মসৃণভাবে "উড়ে যাওয়া" (fly) অ্যানিমেশন তৈরি করতে ব্যবহৃত হয়। এটি দুটি `Hero` উইজেটকে ট্যাগ দ্বারা লিঙ্ক করে কাজ করে। যখন দুটি স্ক্রীনের মধ্যে নেভিগেট করা হয় এবং উভয় স্ক্রীনে একই ট্যাগ সহ একটি `Hero` উইজেট থাকে, তখন Flutter স্বয়ংক্রিয়ভাবে সেই উইজেটটির একটি অ্যানিমেশন তৈরি করে যা এক স্ক্রীন থেকে অন্য স্ক্রীনে স্থানান্তরিত হয়।

এটি UI তে একটি সুন্দর ট্রানজিশন প্রভাব যোগ করে, যা ব্যবহারকারীর অভিজ্ঞতা উন্নত করে।
```
dart
// স্ক্রীন ১
Hero(
  tag: 'imageHero',
  child: Image.network('image_url_1'),
)

// স্ক্রীন ২
Hero(
  tag: 'imageHero',
  child: Image.network('image_url_2'),
)
```
**প্রশ্ন ২০: MediaQuery উইজেট কী এবং এর ব্যবহার কী?**

**উত্তর:** `MediaQuery` উইজেট ডিভাইসের আকার, পিক্সেল ডেনসিটি, টেক্সট স্কেল ফ্যাক্টর এবং অন্যান্য বৈশিষ্ট্য সম্পর্কে তথ্য সরবরাহ করে। `MediaQuery.of(context)` ব্যবহার করে এই তথ্য অ্যাক্সেস করা যায়।

এটি রেসপন্সিভ UI তৈরি করার জন্য অত্যন্ত গুরুত্বপূর্ণ, যেখানে UI ডিভাইসের স্ক্রীন আকারের সাথে খাপ খায়। আপনি স্ক্রীনের উচ্চতা, প্রস্থ, অরিয়েন্টেশন ইত্যাদি পেতে `MediaQuery` ব্যবহার করতে পারেন।